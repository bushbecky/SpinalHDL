package spinal.lib.bus.regif.Document

import spinal.lib.bus.regif.BusIfVisitor
import java.io.PrintWriter
import spinal.core.GlobalData
import scala.collection.mutable
import spinal.lib.bus.regif.AccessType

final case class CHeaderGenerator(
    fileName : String,
    prefix : String,
    regType : String = "u32"
    ) extends BusIfVisitor {
        
    case class Reg(name : String, addr : Long)
    case class Field(name : String, width : Long, accessType : AccessType)
    case class Type(name : String, var fields : List[Field])

    val guardName : String = s"${prefix}_REGIF_H"
    val regs : mutable.ListBuffer[Reg] = mutable.ListBuffer[Reg]()
    val types : mutable.ListBuffer[Type] = mutable.ListBuffer[Type]()
    val fields : mutable.ListBuffer[Field] = mutable.ListBuffer[Field]()
    var curType : Type = null
    var regLength : Int = 0
    var addrLength : Int = 0
    
    def begin(busDataWidth : Int) : Unit = {

    }
    
    def reg(name : String, addr : Long) : Unit = {
        def nameLen = name.length()
        def len = scala.math.log(addr) / scala.math.log(16) + 1

        if(nameLen > regLength)
            regLength = nameLen

        if(len > addrLength)
            addrLength = len.toInt

        regs += Reg(name.toUpperCase().replaceAll("\\s", "_"), addr)

        if(curType != null) {
            curType.fields = fields.toList
            types += curType
        }
        curType = Type(name, null)
        fields.clear
    }
    
    def field(name : String, width : Int, accessType : AccessType, resetValue : Long, doc : String) : Unit = {
        fields += Field(name, width, accessType)
    }
    
    def end() : Unit = {
        val pc = GlobalData.get.phaseContext
        val targetPath = s"${pc.config.targetDirectory}/${fileName}"
        val pw = new PrintWriter(targetPath)

        pw.write(
            s"""|/*
                | * Bus Interface Header - AUTOGENERATED
                | */
                |
                |#ifndef ${guardName}
                |#define ${guardName}
                |
                |""".stripMargin)
        
        for(reg <- regs) {
            pw.write(s"#define ${prefix.toUpperCase()}_${reg.name} ")
            pw.write(" " * (regLength - reg.name.length))
            pw.write("0x")
            pw.print(reg.addr.formatted(s"%0${addrLength}x"))
            pw.println()
        }
        pw.println()

        for(t <- types) {
            val naName = "reserved_"
            var i = -1
            val len = math.max(naName.length + 1, t.fields.map(_.name.length()).fold(0)(math.max(_, _)))

            pw.println("typedef union {")

            pw.println(s"\t$regType val;")

            pw.println("\tstruct {")
            fields.foreach( f => {
                val name = f.accessType match {
                    case AccessType.NA => {
                        i += 1
                        s"reserved_${i}"
                    }
                    case default => f.name
                }
                pw.write(s"\t\t$regType ${name} ")
                pw.write(" " * (len - name.length))                
                pw.println(s": ${f.width.formatted("%2d")};")
            })

            pw.println("\t} reg;")
            pw.println(s"} ${prefix.toLowerCase}_${t.name.toLowerCase()}_t;\n")
        }
        
        pw.write(s"#endif /* ${guardName} */")

        pw.close()
    }
}